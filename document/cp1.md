# 1장 개요

## 등장 배경

- 운영체제가 없던 시절에 하나의 프로세스가 실행 되는 중 다른 자원이 놀고 있어서 이를 효율적으로 사용하기 위해 생겨남
- 여러 프로그램을 동시에 실행할 수 있는 운영체제를 만들어서 쓰자!
  - 하나의 프로세스에서 여러개의 프로세스를 수행함 으로서 하드웨어의 효율적인 자원 활용
  - 여러개의 프로세스의 자원을 서로 공유함으로서 효율적인 자원 활용 및 접근권한의 용이성
    - 하나의 프로세스에 접근해서 여러 프로세스를 컨트롤 할 수 있음

__결론은 Single Process보다 Thread Process가 효율적이다.__

---------

## Thread 이점

* 자원의 활용
     * 하나의 프로세스는 1개의 core를 사용하니깐... 만약 CPU가 4갠데 1개의 프로세스만 돌리면 3개는 놀고 있음
     * 놀게 하지 말고 나머지 3개도 일을 시키자!!
* 모델링
     * 한 플로우는 다음 플로우에 영향을 미치며 이는 소스 컴파일이나 우선순위 지정할 때 개발자의 부담감이 생김
     * 단위 모듈간 테스팅도 되고, 적절한 동기화도 되고, 우선순위 지정도 용이함
* 비동기 이벤트 처리
     * 머 이건.. 비동기로 다중으로 프로세스 수행가능하다라는 내용
     * 하나의 프로세스가 생성할 수 있는 스레드 개수가 제한적이지만 수요에 따른 개수 제한이 늘어나고 있어 점점 더 효용성이 높아지고 있음 
* 빠른 반응의 GUI Event
     * 이벤트 별로 Thread를 띄워두고 해당이벤트 발생 시 해당 Thread를 수행하도록 하면 반응이 빠름~빠름~

-----

## Thread 위험성

* 동기화 문제

  * 별도로 Thread를 수행하면서 전역변수로 하나의 변수를 볼 때 동기화를 재대로 하지 않으면 망함..

  * 그래서 JAVA에서는 synchonized keyword를 사용해서 동기화를 시킴

    ```java
    public class Sequence {
      
      private int value = 0;
      
      public synchronized int incValue(){
        return value++;
      }
      
    }
    ```

* 안정성 문제 ( 10장에서 안정성 문제 관련 내용 다룸)

  * 프로세스가 수행되다가 아래와 같은 갑작스런 문제들이 발생하여 불안정한 상태가 되어 망함..
    * 데드락 ( deadlock ), 라이브락 ( livelock ), 기아현상 ( starvation ) 

* 성능 ( 11장에서 성능 향상 관련 내용 다룸)

  * 자원을 너무 많이 쓰면 컨텍스트 스위칭 할때 부하가 감
  * 다중 쓰레드중 하나의 쓰레드가 자원을 미치도록 잡고 있으면 나머지 쓰레드가 피해를 봄
  * 자원 공유시 동기화 관련 트래픽 문제도 발생함

------

## Thread 많이 씀!

* JVM
  * 기본은 MAIN 문 , GC나 객체종료시에도 사용한다함
* RMI (Remote Method Invocation)
  * 로컬 컴퓨터에서 원격지의 컴퓨터의 메서드를 접근하는 방식이라 각각 Thread로 돌림
* servlet / jsp
  * 각각의 페이지에 접근할때마다 각기다른 프로세스에 접근해야되니까 Thread로 돌림
* 기타
  * timer
    * 스케쥴링 후 수행하려면 스케쥴러 / 프로세스 별로 다른 Thread로 돌림
  * swing
    * 각각의 Event 가 Thread로 돌림