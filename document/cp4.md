#4. 객체구성

[한줄 정리]

객체를 구성할 때, 스레드에 안전하게 구현되어 있는 컴포넌트를 가져다 잘 사용하고 문서를 잘써서 정리를 잘 해놓으면 좋다.

----

##4.1 스레드 안전한 클래스 설계

- 객체의 상태는 항상 객체 내부의 변수를 기반으로 한다
- n개의 변수를 갖는 객체의 상태는 n개의 변수가 가질수 있는 값의 전체 조합이라 볼수 있다.

예를들어

```java
@ThreadSafe
public final class Counter {
	@QuardedBy("this") private long value = 0; //this의 lock에 의해 관리된다고 명시 (jdk1.5)
	
	public synchronized long getValue() {
		return value;
	}

	public synchronized long increment(){
		if (value == long.MAX_VALUE)
			throw new IllegalStateException("countrt overflow");
		return ++value;
	}
}

```




value로 객체 상태를 알수 있다고 함...머 그렇다네.. 목적지향인건가..

- A라는 객체 내부에 다른 객체 B를 가리키는 변수를 사용하고 있다면, A 객체 내부의 변수뿐만 아니라 B 객체 내부에 들어 있는 변수의 조합까지 A 객체가 가질 수 있는 전체 상태 범위에 포함시켜야 한다.
- 객체 내부의 여러 변수가 갖고 있는 현재 상태를 사용하고자 할 때 값이 계속해서 변하는 상황에서도 값을 안전하게 사용할 수 있도록 조절하는 방법을 동기화 정책이라고 한다.

###4.1.1. 동기화 요구사항 정리

- 객체와 변수가 가질 수 있는 가능한 값의 범위를 상태 범위 ( state space ) 라고 한다.
- 특정한 연산을 실행했을 때 올바르지 않은 상태 값을 가질 가능성이 있다면 해당 연산은 단일 연산으로 구현해야 한다. (서로 연관된 값은 단일 연산으로 한번에 읽거나 변경해야 한다.)
- 객체가 가질 수 있는 값의 범위와 변동 폭을 정확하게 인식하지 못한다면, 스레드 안전성을 완벽하게 확보할 수 없다.

###4.1.2 상태 의존 연산

- 현재 조건에 따라 동작 여부가 결정되는 연산을 상태 의존( state dependent ) 연산이라고 한다.
- 자바 내장 명령으로 보자면 wait이나 notify 같은 상태값을 가지고 하는 연산
- 결국 동기화를 위한 건데 wait 와 notify 를 사용하는 대신 세마포어(Semaphore)나 블로킹 큐(Blocking Queue)와 같이 현재 알려져 있는 여러 가지 라이브러리를 사용하는 편이 훨씬 간단하고 안전하다. 

###4.1.3 상태 소유권

- 소유권이란 자바 언어 자체에 내장된 개념은 아니다.
- 변수를 통해 객체의 상태를 정의하고자 할 때에는 해당 객체가 실제로 소유하는 데이터만을 기준으로 삼아야한다.
- "소유권 분리" 는 컬렉션 클래스를 놓고 볼 때 컬렉션 내부의 구조에 대한 소유권은 컬렉션 클래스가 갖고, 컬렉션에 추가되어 있는 객체에 대한 소유권은 컬렉션을 호출해 사용하는 클라이언트 프로그램이 갖는 구조이다.
- 풀어서 보믄 결국 예를들어 변수에 접근 할 때 lock가진애만 접근해서 쓴다는 소리 같은데 무슨 개소린지 모르겠음.

----

##4.2 인스턴스 한정

- 객체를 적절하게 캡슐화하는 것으로도 스레드 안전성을 확보할 수 있는데, 이런 경우 흔히 '한정' 이라고 단순하게 부르기도 하는 '인스턴스 한정' 기법을 사용한 것이다.

예를 들어 한정기법으로는

1. 특정 클래스 인스턴스에 한정 (private 선언 변수)
2. 블록내부에 한정 (블록 내부의 로컬변수)
3. 특정 스레드에 한정 (스레드 내부에서는 메소드를 넘어다닐수 있지만 다른 스레드로 넘기진 않는 객체)

등등이 있다고 한다. 걍 안에서 쓰는 애라는거지 뭐......

- 스레드 안정성을 확보할 수있는 가장 쉬운 방법
- 안전하지 않은 클래스의 안정성을 확보하기 위해 만들어진 클래스도 있다.
- Collections.synchronizedList 와 같은 팩토리 메소드들은 기본 클래스에 스레드 안전성을 확보하는 방법으로 대부분 데코레이터 패턴( Decorator Pattern ) 을 활용하며, 이런 팩토리 메소드의 결과로 만들어진 래퍼클래스는 기본 클래스의 메소드를 호출하는 연동 역할만 하면서 그와 동시에 모든 메소드가 동기화되어 있다.

사용예시

```java
List<T> list = Collections.synchronizedList(new ArrayList<T>());
```

원래 컬랙션 객체가 새로운 래퍼 객체 내부에 제한된 상태라고 한다.
머 이딴 식으로 쓰는거 같은데, 안써봐서 모르겠다....

###4.2.1 자바 모니터 패턴

- 위에 Counter예제 같은 것이 전형적인 자바 모니터 패턴의 예제이다.
- 변수를 내부에 숨기고 변수를 사용하는 모든 메소드는 동기화 되어있다.
- 자바 모니터 패턴을 따르는 객체는 변경가능한 데이터를 모두 객체 내부에 숨긴 다음 객체의 암묵적인 락으로 데이터에 대한 동시 접근을 막는다.
- 객체 자체의 암묵적인 락( 또는 외부에서 사용할 수 있도록 공개되어 있는 락) 을 사용하기 보다는 락으로 활용하기 위한 private 객체를 준비해 두면 여러 가지 장점을 얻을 수 있다.

###4.2.2 차량 위치 추적

- 외부에서 변경 가능한 데이터를 요청할 경우 그에 대한 복사본을 넘겨주는 방법을 사용하면 스레드 안전성을 부분적이나마 확보할 수 있다. 하지만 성능에 문제가 발생할 수 있다. 추가적으로 복사하도록 구현한다면, 외부에서 가져간 정보는 바뀌지 않는다는 점을 알아둬야 한다. 외부 프로그램에서 뭘 하려고 하는지에 따라 장점이 되거나 또는 단점이 될 수도 있다.
- 결국 데이터 복사가 핵심임 (실시간 성이 아닌 스냅샷 데이터)

----

##4.3 스레드 안전성 위임

- 딜리게이트
- 스레드 안전성이 확보된 객체로만 구성된 클래스는 스레드에 안전할 수도 있고, 그렇지 않을 수도 있다.
- 객체가 서로 의존성 없이 독립적이고 스레드 안전한 두 개 이상의 객체를 조합해 만들어져 있고 두 개 이상의 객체를 한번에 처리하는 복합 연산 메소드가 없는 상태라면, 스레드 안정성을 모두 위임할 수 있다.
- 한마디로 AtomicLong이나 ConcurrentMap같은거 써서 스레드 안정성을 확보 할 수 있으나, 두개를 조합해서 먼가 지지고 복고 하면 안전하지 않을 수도 있다. 그런거 같음........그렇단다...

###4.3.1 위임기법을 활용한 차량 추적

- 걍 Map쓰던거 ConcurrentMap쓰고 MutablePointer라고 클래스 만들어 쓰던거 final변수로 된 Point 객체로 바꿔서 씀
- 결국 안전한애 두개 써서 위임하니까 안전하게 만들었다는거 같다.

###4.3.2 독립상태 변수

- 위임하고자 하는 내부 변수가 두 개 이상이라 해도 두 개 이상의 변수가 서로 '독립적'이라면 클래스의 스레드 안전성을 위임할 수 있는데, 독립적이라는 의미는 변수가 서로의 상태 값에 대한 연관성이 없다는 말이다.
- CopyOnWriteArrayList 는 값을 사용할 때 복사한 값을 사용하는 애라고 함. 그래서 사용과 변경에 제약이 없다함. 

###4.3.3 위임할 때의 문제점

- 의존성 조건을 위배하는 상태라면, 각각의 변수가 모두 스레드 안전한 클래스라고 하더라도 전체적으로 스레드 안전성을 잃을 수 있다. 두 개 이상의 변수를 사용하는 복합 연산 메소드를 갖고 있다면 위임 기법만으로는 스레드 안전성을 확보할 수 없다. 이런 경우에는 내부적으로 락을 활용해서 복합 연산이 단일 연산으로 처리되도록 동기화해야 한다.
- 예를들어 값이 두갠데 각각 동시에 돌아가면 원치 않는 값이 나온다는 말

```java
public class NumberRange {
	//의존성 조건 : lower <= upper
	private final AtomicInteger lower = new AtomicInteger(0);
	private final AtomicInteger upper = new AtomicInteger(0);
	
	public void setLower(int i){
		//lower값 셋팅
	}
	
	public void setUpper(int i){
		//upper값 셋팅
	}
	
	public boolean isInRange(int i){
		return ( i >= lower.get() && i <= upper.get());
	}
}
```

스레드 A,B가 각각 작은 걸로 5, 큰걸로 4를 들고 접근하면 결과적으로 (5,4)라는 범위가 나오면서 오류가 생기는 거랄까...

###4.3.4 내부 상태 변수를 외부에 공개

- 상태 변수가 스레드 안전하고, 클래스 내부에서 상태 변수의 값에 대한 의존성을 갖고 있지 않고, 상태 변수에 대한 어떤 연산을 수행하더라도 잘못된 상태에 이를 가능성이 없다면, 해당 변수는 외부에 공개해도 안전하다.
- 걍 상관없는애는 public으로 쓰든 말든 상관없단 소리???

###4.3.5. 차량 추적 프로그램의 상태를 외부에 공개

- 걍 set메소드 하나 만들어서 값 바꿔줄 수 있다? 그냥 핵심은 값이 두개라 동시에 두개 바꾼다는 겉은데? ㅡ.ㅡ; Thread Safe 을 위해서..

----

##4.4 스레드 안전하게 구현된 클래스에 기능 추가

- 만들어져 있는 클래스를 사용하는 것은 좋은 방법이다. 이미 만들어져 있는 클래스를 사용하면 개발에 필요한 시간과 자원을 절약할 수 있고, 개발할 때 오류가 발생할 가능성도 줄어들고 ( 이미 사용 중인 기능은 충분히 테스트가 끝났다고 볼 수 있다. ), 유지보수 비용도 절감할 수 있다.
- 단일 연산 하나를 기존 클래스에 추가하고자 한다면 해당하는 단일 연산 메소드를 기존 클래스에 직접 추가하는 방법이 가장 안전하다.
- 기능을 추가하는 또 다른 방법은 기존 클래스를 상속받는 방법인데, 이 방법은 기존 클래스를 외부에서 상속받아 사용할 수 있도록 설계했을 때나 사용할 수 있다.
  - 기존 클래스를 상속받아 기능을 추가하는 방법은 기존 클래스에 직접 기능을 추가하는 방법보다 문제가 생길 위험이 훨씬 많다. 동기화를 맞춰야 할 대상이 두 개 이상의 클래스에 걸쳐 분산되기 때문이다.

###4.4.1. 호출하는 측의 동기화

- 예를 들어 ListHelper클래스 처럼 list 객체에 락을 걸어야 쓰레드 안전하다.(메소드 자체에 걸면 안된다.)
- putIfAbsent 메소드 자체에 synchronized 키워드만 붙인다고 해서 동기화된 list 객체에서 사용하는 lock과 동일한 lock을 사용하는 것이 아니기 때문이다.

```java
public calss ListHelper<E> {
	public List<E> list = Collections.synchronizedList(new ArrayList<E>());

    public boolean putIfAbsent(E x) {
      synchronized(list) {
        boolean absent = !list.contains(x);
        if (absent) {
          list.add(x);
        }
        return absent;
      }
    }
}
```

###4.4.2. 클래스 재구성

- Composition(재구성) 을 사용하면, 내부 클래스와 다른 수준에서 락을 활용하면서, 해당 클래스의 락을 사용해 동기화하기 때문에 내부 클래스가 스레드 안전한지 아닌지는 중요하지 않고 신경 쓸 필요도 없다. 심지어는 불러다 사용한 클래스가 내부적으로 동기화 정책을 뒤바꾼다 해도 신경 쓸 필요가 없다. 물론 이런 방법으로 동기화 기법을 한 단계 더 사용한다면 전체적인 성능의 측면에서는 약간 부정적인 영향이 있을 수도 있지만, Composition 에서 사용한 동기화 기법은 이전에 사용했던 클라이언트 측 락 등의 방법보다 훨씬 안전하다.
- 재구성 기법으로 만든 예는 결국 모니터 패턴인가 걔랑 비슷
- 오버헤드는 더 발생할 수있으나 안전성은 좋다함
- 클래스 자체에 락을 사용해서 내부적으로 List클래가 무슨 짓을 해도 안전하다함.

```java
@ThreadSafe
public calss ImprovedList<T> implements List<T>{
	private final List<T> list;
	public ImprovedList (List<T> list) {this.list = list;}
	public synchronized boolean putIfAbsent(T x){
		boolean contains = !list.contains(x);
	        	if (!contains) {
	            	list.add(x);
	        	}
	        	return !contains;
	}
}
```

----

##4.5 동기화 정책 문서화

설계단계에서 정책에 대한 문서화를 써놔라.

최소한 @GuardedBy annotation (Java 1.5부터 지원)을 이용하여 어느 변수가 동기화되는지라도 써놔라.

애매하게 쓰지마라. 명시적으로 써라.